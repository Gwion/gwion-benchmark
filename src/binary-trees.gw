#! Ported from the Wren version.

class Tree {
  var int item;
  var Tree? left, right;

  fun static Tree new_Tree(int it, int depth) {
    var Tree t;
    it => t.item;
    if (depth > 0) {
      it + it => var int item2;
      --depth;
      new_Tree(item2 - 1, depth) @=> t.left.val;
      new_Tree(item2, depth) @=> t.right.val;
    }
    return t;
  }

  fun int check() {
    if (!left.is(val))
      return item;
    return item + left.val.check() - right.val.check();
  }
}

4 => var int minDepth;
12 => var int maxDepth;
maxDepth + 1 => var int stretchDepth;

<<< "stretch tree of depth ", stretchDepth, " check: ",
  Tree.new_Tree(0, stretchDepth).check() >>>;

Tree.new_Tree(0, maxDepth) @=> var Tree longLivedTree;

#! iterations = 2 ** maxDepth
1 => var int iterations;
for (var int d; d < maxDepth; ++d)
  2 *=> iterations;

minDepth => var int depth;
while (depth < stretchDepth) {
  var int check;
  for (var int i; i < iterations; ++i)
    Tree.new_Tree(i, depth).check() + Tree.new_Tree(-i, depth).check() +=> check;

  <<< iterations * 2, " trees of depth ", depth, " check: ", check >>>;
  4 /=> iterations;
  2 +=> depth;
}

<<< "long lived tree of depth ", maxDepth, " check: ", longLivedTree.check() >>>;
